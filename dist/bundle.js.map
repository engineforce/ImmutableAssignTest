{"version":3,"sources":["webpack:///webpack/bootstrap 4e8e871e93b698d0dd4d","webpack:///./~/deep-freeze-strict/index.js","webpack:///./~/immutable-assign/src/iassign.js","webpack:///./index.ts"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AChEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;gGCjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAA+C;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,0CAA0C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,oGAAoG;AACpG;AACA;AACA,oGAAoG;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAA+C;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA,6CAA6C,uBAAuB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,KAAK,MAAM,KAAK,MAAM,KAAK;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;AChcD,+CAA+C;AAC/C,uCAA4C;AAE5C,OAAO,CAAC,SAAS,CAAC;IACd,MAAM,EAAE,IAAI;CACf,CAAC,CAAC;AAEH,IAAI,IAAI,GAAG,EAAE,CAAC,EAAC,CAAC,EAAE,CAAC,EAAC,CAAC,EAAE,CAAC,EAAC,CAAC,EAAE,CAAC;AAE7B,2DAA2D;AAC3D,IAAI,IAAI,GAAG,OAAO,CACd,IAAI,EACJ,CAAC,CAAC;IACE,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC;IACT,MAAM,CAAC,CAAC,CAAC;AACb,CAAC,CACJ,CAAC;AAEF,EAAE,CAAC,CAAC,OAAO,QAAQ,KAAK,WAAW,CAAC,CAAC,CAAC;IAClC,QAAQ,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC,SAAS,IAAI,MAAM,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC;IAChF,QAAQ,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC,SAAS,IAAI,MAAM,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC;AACpF,CAAC;AACD,IAAI,CAAC,CAAC;IACF,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IAClB,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AACtB,CAAC","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4e8e871e93b698d0dd4d","module.exports = function deepFreeze (o) {\n  Object.freeze(o);\n\n  var oIsFunction = typeof o === \"function\";\n  var hasOwnProp = Object.prototype.hasOwnProperty;\n\n  Object.getOwnPropertyNames(o).forEach(function (prop) {\n    if (hasOwnProp.call(o, prop)\n    && (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true )\n    && o[prop] !== null\n    && (typeof o[prop] === \"object\" || typeof o[prop] === \"function\")\n    && !Object.isFrozen(o[prop])) {\n      deepFreeze(o[prop]);\n    }\n  });\n  \n  return o;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/deep-freeze-strict/index.js\n// module id = 0\n// module chunks = 0","\"use strict\";\n(function (root, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        try {\n            var deepFreeze = require(\"deep-freeze-strict\");\n        }\n        catch (ex) {\n            console.warn(\"Cannot load deep-freeze-strict module, however you can still use iassign() function.\");\n        }\n        var v = factory(deepFreeze, exports);\n        if (v !== undefined)\n            module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"deep-freeze-strict\", \"exports\"], factory);\n    }\n    else {\n        // Browser globals (root is window)\n        root.iassign = factory(root.deepFreeze, {});\n    }\n})(this, function (deepFreeze, exports) {\n    var autoCurry = (function () {\n        var toArray = function toArray(arr, from) {\n            return Array.prototype.slice.call(arr, from || 0);\n        };\n        var curry = function curry(fn /* variadic number of args */) {\n            var args = toArray(arguments, 1);\n            return function curried() {\n                return fn.apply(this, args.concat(toArray(arguments)));\n            };\n        };\n        return function autoCurry(fn, numArgs) {\n            numArgs = numArgs || fn.length;\n            return function autoCurried() {\n                if (arguments.length < numArgs) {\n                    return numArgs - arguments.length > 0 ?\n                        autoCurry(curry.apply(this, [fn].concat(toArray(arguments))), numArgs - arguments.length) :\n                        curry.apply(this, [fn].concat(toArray(arguments)));\n                }\n                else {\n                    return fn.apply(this, arguments);\n                }\n            };\n        };\n    }());\n    var iassign = _iassign;\n    iassign.fp = autoCurry(_iassignFp);\n    iassign.maxGetPropCacheSize = 100;\n    iassign.setOption = function (option) {\n        copyOption(iassign, option);\n    };\n    // Immutable Assign\n    function _iassign(obj, // Object to set property, it will not be modified.\n        getPropOrSetProp, // Function to get property to be updated. Must be pure function.\n        setPropOrOption, // Function to set property.\n        contextOrUndefined, // (Optional) Context to be used in getProp().\n        optionOrUndefined) {\n        var getProp = getPropOrSetProp;\n        var setProp = setPropOrOption;\n        var context = contextOrUndefined;\n        var option = optionOrUndefined;\n        if (typeof setPropOrOption !== \"function\") {\n            getProp = undefined;\n            setProp = getPropOrSetProp;\n            context = undefined;\n            option = setPropOrOption;\n        }\n        option = copyOption(undefined, option, iassign);\n        if (deepFreeze && (option.freeze || option.freezeInput)) {\n            deepFreeze(obj);\n        }\n        if (!getProp) {\n            var newValue = undefined;\n            if (option.ignoreIfNoChange) {\n                newValue = setProp(obj);\n                if (newValue === obj) {\n                    return obj;\n                }\n            }\n            obj = quickCopy(obj, option.useConstructor);\n            obj = option.ignoreIfNoChange ? newValue : setProp(obj);\n        }\n        else {\n            // Check if getProp() is valid\n            var value = getProp(obj, context);\n            var newValue = undefined;\n            if (option.ignoreIfNoChange) {\n                newValue = setProp(value);\n                if (newValue === value) {\n                    return obj;\n                }\n            }\n            var getPropFuncInfo = parseGetPropFuncInfo(getProp, option);\n            obj = updateProperty(obj, setProp, newValue, context, getPropFuncInfo, option);\n        }\n        if (deepFreeze && (option.freeze || option.freezeOutput)) {\n            deepFreeze(obj);\n        }\n        return obj;\n    }\n    function _iassignFp(option, getProp, setProp, context, obj) {\n        return _iassign(obj, getProp, setProp, context, option);\n    }\n    // For performance\n    function copyOption(target, option, defaultOption) {\n        if (target === void 0) { target = {}; }\n        if (defaultOption) {\n            target.freeze = defaultOption.freeze;\n            target.freezeInput = defaultOption.freezeInput;\n            target.freezeOutput = defaultOption.freezeOutput;\n            target.useConstructor = defaultOption.useConstructor;\n            target.disableAllCheck = defaultOption.disableAllCheck;\n            target.disableHasReturnCheck = defaultOption.disableHasReturnCheck;\n            target.disableExtraStatementCheck = defaultOption.disableExtraStatementCheck;\n            target.maxGetPropCacheSize = defaultOption.maxGetPropCacheSize;\n            target.ignoreIfNoChange = defaultOption.ignoreIfNoChange;\n        }\n        if (option) {\n            if (option.freeze != undefined) {\n                target.freeze = option.freeze;\n            }\n            if (option.freezeInput != undefined) {\n                target.freezeInput = option.freezeInput;\n            }\n            if (option.freezeOutput != undefined) {\n                target.freezeOutput = option.freezeOutput;\n            }\n            if (option.useConstructor != undefined) {\n                target.useConstructor = option.useConstructor;\n            }\n            if (option.disableAllCheck != undefined) {\n                target.disableAllCheck = option.disableAllCheck;\n            }\n            if (option.disableHasReturnCheck != undefined) {\n                target.disableHasReturnCheck = option.disableHasReturnCheck;\n            }\n            if (option.disableExtraStatementCheck != undefined) {\n                target.disableExtraStatementCheck = option.disableExtraStatementCheck;\n            }\n            if (option.maxGetPropCacheSize != undefined) {\n                target.maxGetPropCacheSize = option.maxGetPropCacheSize;\n            }\n            if (option.ignoreIfNoChange != undefined) {\n                target.ignoreIfNoChange = option.ignoreIfNoChange;\n            }\n        }\n        return target;\n    }\n    function updateProperty(obj, setProp, newValue, context, getPropFuncInfo, option) {\n        var propValue = undefined;\n        for (var propIndex = 0; propIndex < getPropFuncInfo.funcTokens.length; ++propIndex) {\n            var _a = getPropFuncInfo.funcTokens[propIndex], propName = _a.propName, propNameSource = _a.propNameSource, subAccessorText = _a.subAccessorText, getPropName = _a.getPropName;\n            //console.log(propName);\n            if (propIndex <= 0) {\n                propValue = quickCopy(obj, option.useConstructor);\n                if (!subAccessorText) {\n                    propValue = option.ignoreIfNoChange ? newValue : setProp(propValue);\n                }\n                obj = propValue;\n            }\n            else {\n                var prevPropValue = propValue;\n                if (propName == undefined) {\n                    propName = getPropName(obj, context);\n                }\n                propValue = propValue[propName];\n                propValue = quickCopy(propValue, option.useConstructor);\n                if (!subAccessorText) {\n                    propValue = option.ignoreIfNoChange ? newValue : setProp(propValue);\n                }\n                prevPropValue[propName] = propValue;\n            }\n            //console.log(propValue);\n        }\n        return obj;\n    }\n    var ePropNameSource;\n    (function (ePropNameSource) {\n        ePropNameSource[ePropNameSource[\"none\"] = 0] = \"none\";\n        ePropNameSource[ePropNameSource[\"beforeDot\"] = 1] = \"beforeDot\";\n        ePropNameSource[ePropNameSource[\"beforeBracket\"] = 2] = \"beforeBracket\";\n        ePropNameSource[ePropNameSource[\"inBracket\"] = 3] = \"inBracket\";\n        ePropNameSource[ePropNameSource[\"last\"] = 4] = \"last\";\n    })(ePropNameSource || (ePropNameSource = {}));\n    var getPropCaches = {};\n    var getPropCacheKeys = [];\n    function parseGetPropFuncInfo(func, option) {\n        var funcText = func.toString();\n        var cacheKey = funcText + JSON.stringify(option);\n        var info = getPropCaches[cacheKey];\n        if (getPropCaches[cacheKey]) {\n            return info;\n        }\n        var matches = /\\(([^\\)]*)\\)/.exec(funcText);\n        var objParameterName = undefined;\n        var cxtParameterName = undefined;\n        if (matches) {\n            var parametersText = matches[1];\n            var parameters = parametersText.split(\",\");\n            objParameterName = parameters[0];\n            cxtParameterName = parameters[1];\n        }\n        if (objParameterName) {\n            objParameterName = objParameterName.trim();\n        }\n        if (cxtParameterName) {\n            cxtParameterName = cxtParameterName.trim();\n        }\n        var bodyStartIndex = funcText.indexOf(\"{\");\n        var bodyEndIndex = funcText.lastIndexOf(\"}\");\n        var bodyText = \"\";\n        if (bodyStartIndex > -1 && bodyEndIndex > -1) {\n            bodyText = funcText.substring(bodyStartIndex + 1, bodyEndIndex);\n        }\n        else {\n            var arrowIndex = funcText.indexOf(\"=>\");\n            if (arrowIndex > -1) {\n                //console.log(\"Handle arrow function.\");\n                bodyText = \"return \" + funcText.substring(arrowIndex + 3);\n            }\n            else {\n                throw new Error(\"Cannot parse function: \" + funcText);\n            }\n        }\n        var accessorTextInfo = getAccessorTextInfo(bodyText, option);\n        info = {\n            objParameterName: objParameterName,\n            cxtParameterName: cxtParameterName,\n            bodyText: bodyText,\n            accessorText: accessorTextInfo.accessorText,\n            quotedTextInfos: accessorTextInfo.quotedTextInfos,\n            funcTokens: parseGetPropFuncTokens(accessorTextInfo.accessorText),\n        };\n        postProcessTokens(info);\n        if (option.maxGetPropCacheSize > 0) {\n            getPropCaches[cacheKey] = info;\n            getPropCacheKeys.push(cacheKey);\n            if (getPropCacheKeys.length > option.maxGetPropCacheSize) {\n                debugger;\n                var cacheKeyToRemove = getPropCacheKeys.shift();\n                delete getPropCaches[cacheKeyToRemove];\n            }\n        }\n        return info;\n    }\n    function parseGetPropFuncTokens(accessorText) {\n        var tokens = [];\n        while (accessorText) {\n            var openBracketIndex = accessorText.indexOf(\"[\");\n            var closeBracketIndex = accessorText.indexOf(\"]\");\n            var dotIndex = accessorText.indexOf(\".\");\n            var propName = \"\";\n            var propNameSource = ePropNameSource.none;\n            // if (dotIndex == 0) {\n            //     accessorText = accessorText.substr(dotIndex + 1);\n            //     continue;\n            // }\n            if (openBracketIndex > -1 && closeBracketIndex <= -1) {\n                throw new Error(\"Found open bracket but not close bracket.\");\n            }\n            if (openBracketIndex <= -1 && closeBracketIndex > -1) {\n                throw new Error(\"Found close bracket but not open bracket.\");\n            }\n            if (dotIndex > -1 && (dotIndex < openBracketIndex || openBracketIndex <= -1)) {\n                propName = accessorText.substr(0, dotIndex);\n                accessorText = accessorText.substr(dotIndex + 1);\n                propNameSource = ePropNameSource.beforeDot;\n            }\n            else if (openBracketIndex > -1 && (openBracketIndex < dotIndex || dotIndex <= -1)) {\n                if (openBracketIndex > 0) {\n                    propName = accessorText.substr(0, openBracketIndex);\n                    accessorText = accessorText.substr(openBracketIndex);\n                    propNameSource = ePropNameSource.beforeBracket;\n                }\n                else {\n                    propName = accessorText.substr(openBracketIndex + 1, closeBracketIndex - 1);\n                    accessorText = accessorText.substr(closeBracketIndex + 1);\n                    propNameSource = ePropNameSource.inBracket;\n                }\n            }\n            else {\n                propName = accessorText;\n                accessorText = \"\";\n                propNameSource = ePropNameSource.last;\n            }\n            propName = propName.trim();\n            if (propName == \"\") {\n                continue;\n            }\n            //console.log(propName);\n            tokens.push({\n                propName: propName,\n                propNameSource: propNameSource,\n                subAccessorText: accessorText,\n            });\n        }\n        return tokens;\n    }\n    function postProcessTokens(getPropFuncInfo) {\n        var _loop_1 = function () {\n            var token = getPropFuncInfo.funcTokens[propIndex];\n            var propName = token.propName, propNameSource = token.propNameSource, subAccessorText = token.subAccessorText;\n            if (propNameSource == ePropNameSource.inBracket && isNaN(propName)) {\n                if (propName[0] == \"#\") {\n                    var quotedPropName = getPropFuncInfo.quotedTextInfos[propName];\n                    if (!quotedPropName) {\n                        throw new Error(\"Cannot find quoted text for \" + quotedPropName);\n                    }\n                    propName = eval(quotedPropName);\n                    token.propName = propName;\n                }\n                else {\n                    var statement_1 = \"'use strict';\\n\";\n                    if (getPropFuncInfo.objParameterName) {\n                        statement_1 += \"var \" + getPropFuncInfo.objParameterName + \" = arguments[1];\\n\";\n                    }\n                    if (getPropFuncInfo.cxtParameterName) {\n                        statement_1 += \"var \" + getPropFuncInfo.cxtParameterName + \" = arguments[2];\\n\";\n                    }\n                    statement_1 += \"\" + propName;\n                    token.propName = undefined;\n                    token.getPropName = function (obj, context) {\n                        return evalStatement(statement_1, obj, context);\n                    };\n                }\n            }\n        };\n        for (var propIndex = 0; propIndex < getPropFuncInfo.funcTokens.length; ++propIndex) {\n            _loop_1();\n        }\n    }\n    function getAccessorTextInfo(bodyText, option) {\n        var returnIndex = bodyText.indexOf(\"return \");\n        if (!option.disableAllCheck && !option.disableHasReturnCheck) {\n            if (returnIndex <= -1) {\n                throw new Error(\"getProp() function has no 'return' keyword.\");\n            }\n        }\n        if (!option.disableAllCheck && !option.disableExtraStatementCheck) {\n            var otherBodyText = bodyText.substr(0, returnIndex);\n            otherBodyText = otherBodyText.replace(/['\"]use strict['\"];*/g, \"\");\n            otherBodyText = otherBodyText.trim();\n            if (otherBodyText != \"\") {\n                throw new Error(\"getProp() function has statements other than 'return': \" + otherBodyText);\n            }\n        }\n        var accessorText = bodyText.substr(returnIndex + 7).trim();\n        if (accessorText[accessorText.length - 1] == \";\") {\n            accessorText = accessorText.substring(0, accessorText.length - 1);\n        }\n        accessorText = accessorText.trim();\n        return parseTextInQuotes(accessorText, option);\n    }\n    function parseTextInQuotes(accessorText, option) {\n        var quotedTextInfos = {};\n        var index = 0;\n        while (true) {\n            var singleQuoteIndex = accessorText.indexOf(\"'\");\n            var doubleQuoteIndex = accessorText.indexOf('\"');\n            var varName = \"#\" + index++;\n            if (singleQuoteIndex <= -1 && doubleQuoteIndex <= -1)\n                break;\n            var matches = undefined;\n            var quoteIndex = void 0;\n            if (doubleQuoteIndex > -1 && (doubleQuoteIndex < singleQuoteIndex || singleQuoteIndex <= -1)) {\n                matches = /(\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\")/.exec(accessorText);\n                quoteIndex = doubleQuoteIndex;\n            }\n            else if (singleQuoteIndex > -1 && (singleQuoteIndex < doubleQuoteIndex || doubleQuoteIndex <= -1)) {\n                matches = /('[^'\\\\]*(?:\\\\.[^'\\\\]*)*')/.exec(accessorText);\n                quoteIndex = singleQuoteIndex;\n            }\n            if (matches) {\n                quotedTextInfos[varName] = matches[1];\n                accessorText =\n                    accessorText.substr(0, quoteIndex) +\n                        varName +\n                        accessorText.substr(matches.index + matches[1].length);\n            }\n            else {\n                throw new Error(\"Invalid text in quotes: \" + accessorText);\n            }\n        }\n        return {\n            accessorText: accessorText,\n            quotedTextInfos: quotedTextInfos,\n        };\n    }\n    function quickCopy(value, useConstructor) {\n        if (value != undefined && !(value instanceof Date)) {\n            if (value instanceof Array) {\n                return value.slice();\n            }\n            else if (typeof (value) === \"object\") {\n                if (useConstructor) {\n                    var target = new value.constructor();\n                    return extend(target, value);\n                }\n                return extend({}, value);\n            }\n        }\n        return value;\n    }\n    function extend(destination) {\n        var sources = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            sources[_i - 1] = arguments[_i];\n        }\n        for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {\n            var source = sources_1[_a];\n            for (var key in source) {\n                if (!Object.prototype.hasOwnProperty.call(source, key)) {\n                    continue;\n                }\n                var value = source[key];\n                if (value !== undefined) {\n                    destination[key] = value;\n                }\n            }\n        }\n        return destination;\n    }\n    function evalStatement() {\n        return eval(arguments[0]);\n    }\n    // function isTextInQuote(text: string): boolean {\n    //     let quoteMarks = [\"'\", '\"'];\n    //     for (let mark of quoteMarks) {\n    //         if (text[0] == mark && text[text.length-1] == mark) {\n    //             return true;\n    //         }\n    //     }\n    //     return false;\n    // }\n    // function extractTextInQuote(text: string): string {\n    //     let quoteMarks = [\"'\", '\"'];\n    //     for (let mark of quoteMarks) {\n    //         if (text[0] == mark) {\n    //             let regex = new RegExp(`^[${mark}]([^${mark}]*)[${mark}]$`);\n    //             let match = regex.exec(text);\n    //             if (match) {\n    //                 return match[1];\n    //             }\n    //         }\n    //     }\n    //     return undefined;\n    // }\n    return iassign;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/immutable-assign/src/iassign.js\n// module id = 1\n// module chunks = 0","//import iassign = require('immutable-assign');\r\nimport * as iassign from \"immutable-assign\";\r\n\r\niassign.setOption({\r\n    freeze: true,\r\n});\r\n \r\nvar map1 = { a:1, b:2, c:3 };\r\n \r\n// 1: Calling iassign() to update map1.b, using overload 2 \r\nvar map2 = iassign(\r\n    map1,\r\n    (m) => {\r\n        m.b = 50;\r\n        return m;\r\n    }\r\n);\r\n\r\nif (typeof document !== \"undefined\") {\r\n    document.querySelector(\"#status\").innerHTML += `<p>${JSON.stringify(map1)}</p>`;\r\n    document.querySelector(\"#status\").innerHTML += `<p>${JSON.stringify(map2)}</p>`;\r\n}\r\nelse {\r\n    console.log(map1);\r\n    console.log(map2);\r\n}\n\n\n// WEBPACK FOOTER //\n// ./index.ts"],"sourceRoot":""}